### 浅谈Python中的GIL

#### 目录

- [什么是GIL](#什么是GIL)
- [为什么会有GIL](#为什么会有GIL)
- [为什么是GIL](#为什么是GIL)
- [GIL对程序的影响](#GIL对程序的影响)
- [GIL为什么没有移除](#GIL为什么没有移除)
- [GIL，爱你或是不爱](#GIL，爱你或是不爱)



当我们学完了Python的基础， 想要更近一步的时候， 总免不了与一个东西打交道：GIL， 没错就是它， 可能你很早就听说过它，如果有足够的了解， 那你就可以跳过这边文章了， 如果你只是有一个概念，局限于听过这个名词或者了解一点点， 这篇文章还是对你有所帮助的。

#### 什么是GIL

GIL全程是Global Interpreter Lock，翻译过来就是全局解释器锁。它是一个互斥(mutex)锁，这意味着一个python解释器在任何时间点上都只有一个线程可以处于执行状态。

如果你的程序是单线程的， 那么它对于你几乎没有什么影响。但是在计算密集型或者多线程的场景下， 它就会导致性能瓶颈了， 因为尽管你可能有一个强劲勇猛的U（cpu），什么八核十六线程啊，但是只要我（GIL）存在， 你就只能老老实实的单线程运行。

看到这里你应该会想：这么一个‘糟糕’的特性， 为什么会存在呢？不忙， 往下看。

Note：计算机任务分为计算密集型和IO密集型，即CPU-bound和IO-bound，在CPU-bound场景下我们的程序大部分时间花在cpu计算上， 如复杂的数学计算、图形图像处理等等， 而IO-bound场景下程序多数时候处于等待网络返回、读取和写入文件，此时cpu处于闲置状态。



#### 为什么会有GIL

在python中， 我们不需要自行申请和释放内存空间：内存管理机制帮我做了这一切。python的内存管理采取了一种称为“引用计数”的策略来管理内存，简单点来说， 每当我们创建了一个对象（python中一切皆为对象）就会有一个引用计数变量，这个变量会跟踪指向该对象的引用数，一旦这个计数变为零，就表示它不再需要了， 然后被释放掉。

举个例子，在REPL中执行下面的语句：

```python
import sys
a = 333
b = a
sys.getrefcount(a)
>>> 3
```

在上面的例子中我们用sys.getrefcount函数来得到333的引用数， 显示的是3，因为这个对象被a、b和作为参数传递给sys.getrefcount所引用。

回到GIl上来。

这里有个问题就是， 如果我们有多个线程， 那么这个引用计数变量就需要防止多线程对其同时操作， 因为这可能导致此变量被不正确的修改，一旦发生这种情况，内存就可能会泄露， 更糟糕的是， 如果你的对象任然存在，却被另一个线程释放， 你的程序可能就会因此而崩溃。

有一个办法可以解决这个问题：加锁。

也就是说， 每当一个线程想修改一个共享数据的时候，都需要先拿到锁，告诉别人，此时只能这个线程操作， 操作完了过后释放锁。但是， 如此一来， 我们就需要对每个对象加锁，这不仅会导致程序性能下降：重复的获取和释放锁，同时还可能导致死锁。譬如说，线程A和线程B执行都需要两把锁a、b，现在的情况是线程A获取到了锁a等待锁b，而线程B刚好反过来， 结果就是谁也不得不到想要的、执行不下去， 也不释放锁。这显然不是我们想要的。

这个时候GIL的作用就体现出来了， 它是解释器级别的锁，这意味着它不仅能防止死锁（毕竟只有它这一把锁），而且性能开销也不会太大。

它制定了一个规矩：任何字节码想运行可以，前提是你得拿到我。

所以，现在我们知道了GIL存在的意义了。



#### 为什么是GIL

现在可能又一个疑问来了：其他语言为什么就可以多线程，譬如java，为啥你python就得来个GIL？

这大约也是多数人选择学python的原因：简单，你不用过多的关注底层的东西。内存管理、垃圾回收等等这一切，它都替你搞定了。

python能如此流行、大规模的被接受GIL功不可没。在操作系统还没有线程的概念的时候， python就诞生了， 它设计理念就是易用、快速开发。

python的很多扩展都是用C库编写的，为了防止不一致的修改， python为这些扩展提供了GIL，一个线程安全的内存管理机制。如此一来非线程安全的C库变得很容易集成。

所以， GIL虽然有它的局限性，但是它也确实解决了早期CPython开发人员面临的问题。



#### GIL对程序的影响

前面我们提到了一点：程序分为计算密集型和IO密集型。这里再次提及是因为对于不同类型的程序， GIL的影响也是不同的。

我们先来看一个简单的计算密集型示例：

```python
# single_cpu_bound.py
import time

COUNT = 50_000_000


def count_down():
    global COUNT
    while COUNT > 0:
        COUNT -= 1


s = time.perf_counter()
count_down()
c = time.perf_counter() - s
print('time taken in seconds - >:', c)

# python single_cpu_bound.py
>>> time taken in seconds - >: 5.980882453

```

这个是单线程， 时间是快6s， 下面我们用两个线程看看结果又如何：

```python
# multi_cpu_bound.py
import time
from threading import Thread

COUNT = 50_000_000

def count_down():
    global COUNT
    while COUNT > 0:
        COUNT -= 1

s = time.perf_counter()
t1 = Thread(target=count_down)
t2 = Thread(target=count_down)
t1.start()
t2.start()
t1.join()
t2.join()
c = time.perf_counter() - s
print('time taken in seconds - >:', c)
```

先猜猜结果回事什么样子？

如果你认为时间不会减少甚至会增加， 说明你对此已经有些理解了。

事实确实如此， 在我电脑上， 运行了三次， 最好的结果是：

```python
# python multi_cpu_bound.py
time taken in seconds - >: 9.614327945000001
```

一点也不奇怪， 我们程序主要的操作就是在计算， cpu没有等待， 而改为多线程后， 增加了线程后， 在线程之间频繁的切换，增大了时间开销， 时间当然会增加了。

因为本篇内容重点是GIL而不是多线程与多进程，故不再探求其他场景。



#### GIL为什么没有移除

GIL算是个老资历了， 前面我们也讲到很多C扩展都是依赖于GIL提供解决方案而且还有些兼容性问题，因此移除GIL并不容易，但是并不意味这它是不可移出的。

python的创建者曾就这个问题说过：除非让单线程程序（IO密集型下的多线程）的性能不会下降时，我才欢迎这样一组补丁。

这个条件，说实话很难达到。



#### GIL，爱你或是不爱

有一点需要明白：GIL并不是总是存在的。

python有多个实现版本CPython、Jython、IronPython和PyPy。GIL只存在于最初的版本CPython之中，而这个版本又是使用最广泛的， 我们说python除非特殊提及默认就是这个版本。

如果你不是在编写一些C扩展程序或者进行计算密集型的任务， 说实话GIL并不会对你产生多少影响。因为在进行计算密集型的任务时我们也可以选择多进程来解决这个问题。当然， 这需要额外的开销，毕竟多进程在python中相当于启动了多个python解释器， 这可比线程‘重’多了。而在IO密集型任务中， 我们可以使用多线程实现并发， 这对于加速我们的程序也是不错的选择。

至于好与坏，没有绝对， 事物总是具有两面性，有了GIL你可以进行快速开发不用过多考虑内存管理等。同时有了它也意味着想要真正的并行我们就只能通过多进程，增加一些额外的开销。

爱或者不爱，它都在那里。